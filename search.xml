<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Evaluation-评价类模型</title>
    <url>/2025/04/22/Evaluation/</url>
    <content><![CDATA[
评价类模型是数学建模中非常重要的一类模型，主要用于对方案、系统或对象进行评价、比较和排序。
一、常见评价类模型1. 主观赋权评价法（1）层次分析法(AHP)是在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法。
流程：

构建层次结构：目标层→准则层→方案层

构造判断矩阵：采用1-9标度法两两比较

计算权重：特征向量法&#x2F;几何平均法

一致性检验：计算CI和CR（要求CR&lt;0.1）

综合权重计算：各层级权重叠加


权重：判断矩阵中两个元素的重要性对比



优点
缺点



① 系统性结构清晰，适合多准则决策
① 主观性强，依赖专家经验


② 能处理定性和定量结合的问题
② 指标过多时一致性检验难通过


③ 1-9标度法便于专家打分
③ 判断矩阵构建可能存在逻辑矛盾



（2）模糊综合评价法模糊综合评价的基本原理是从影响问题的诸因素出发，确定被评价对象从优到劣若干等级的评价集合和评价指标的权重，对各指标分别做出相应的模糊评价，确定隶属函数，形成模糊判断矩阵，将其与权重矩阵进行模糊运算，得到定量的综合评价结果。
学术论文中，采用层次分析和模糊综合评价相结合的方法对研究主题的评价指标体系构建并打分评估，因此因素集可直接采用层次分析法的各个指标因素。
流程：

确定因素集和评语集
构建隶属度矩阵（模糊关系矩阵）
确定权重向量
合成运算：常用M(∧,∨)或加权平均算子
去模糊化（如需精确结果）




优点
缺点



① 擅长处理模糊性评价问题
① 隶属函数确定较主观


② 可结合语言变量（如”优&#x2F;良&#x2F;差”）
② 可能丢失原始数据信息


③ 算子选择灵活（M(∧,∨)、加权平均等）
③ 最大隶属度原则可能失效



（3）主成分分析PCA流程：

数据标准化：消除量纲影响
计算相关系数矩阵
求特征值和特征向量
确定主成分个数：累计贡献率≥85%
计算主成分得分：线性组合原始变量






优点
缺点



① 消除指标间相关性
① 主成分物理意义不明确


② 客观性强，完全数据驱动
② 要求大样本数据（n&gt;5p）


③ 有效降低数据维度
③ 对非线性关系处理效果差



2. 客观赋权评价法（1）熵权法
数据标准化
计算指标比重
计算信息熵
计算差异系数
确定权重




优点
缺点



① 完全客观赋权
① 对极端值敏感


② 自动放大差异显著指标的权重
② 无法反映指标实际重要性


③ 计算简单易实现
③ 若数据无波动则失效



（2）因子分析法
与PCA类似，但更注重解释变量间的潜在结构




对比项
因子分析（FA）
主成分分析（PCA）



目标
解释变量间的协方差结构
最大化方差解释


假设
存在潜在因子模型
无模型假设


输出
因子载荷矩阵、因子得分
主成分载荷、成分得分


旋转
通常需旋转（如方差最大化）
无需旋转





优点
缺点



降维减少变量数量
需变量间存在相关性（否则无效）


揭示潜在结构，增强解释性
因子命名依赖主观判断


可处理多重共线性问题
数据需满足一定假设（如KMO&gt;0.6）


适用于连续变量
对异常值敏感



3. 组合评价法
TOPSIS法(优劣解距离法)

TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确地反映各评价方案之间的差距。

构建决策矩阵并标准化
确定正理想解和负理想解
计算各方案到正负理想解的距离：
计算相对贴近度




优点
缺点



① 直观反映与理想解的差距
① 权重需其他方法确定


② 适用于多属性排序问题
② 欧氏距离可能失真


③ 结果易于解释（0-1贴近度）
③ 对异常值敏感



4. 其他评价方法（1）数据包络分析(DEA)是一种非参数效率评价方法，用于衡量具有多输入多输出的决策单元（DMU）的相对效率。它通过线性规划构建生产前沿面，无需预设生产函数形式，广泛应用于企业、银行、医院等组织的效率评估。

确定DMU（决策单元）
选择输入&#x2F;输出指标
构建CCR&#x2F;BCC模型：
CCR模型（规模报酬不变）
BCC模型（规模报酬可变）


求解线性规划：计算θ效率值
结果分析：有效性判断(θ&#x3D;1有效)




优点
缺点



① 无需预设生产函数形式
① 对指标数量有限制（2(m+s)≤n）


② 可处理多输入多输出系统
② 无法区分有效DMU（θ&#x3D;1的单元）


③ 直接输出效率值（0-1）
③ 易受极端值影响



（2）灰色关联分析法通过计算序列间的几何形状相似度（灰色关联度），衡量因素间的关联程度。核心思想是：

数据序列曲线的几何形状越接近，关联度越大适用于”小样本、贫信息”的不确定性系统（无需典型分布规律）

要利用该方法，这个系统必须是灰色系统。灰色系统中灰的主要含义是信息不完全性（部分性）和非唯一性，其中的“非唯一性”是灰色系统的重要特征，非唯一性原理在决策上的体现是灰靶思想，即体现的是决策多目标、方法多途径，处理态度灵活机动。需要理想参照。

确定参考序列和比较序列参考序列（母序列）比较序列（子序列）

数据标准化处理：消除量纲影响，常用方法：均值化，初值化（适合时序数据），区间相对化。

计算关联系数





计算关联度

排序分析





优点
缺点



① 适合”小样本贫信息”系统
① 分辨系数ρ取值影响结果


② 计算量小，操作简单
② 对数据波动较敏感


③ 不需要典型分布规律
③ 关联度区分度可能不足


改进：

权重优化：
引入熵权法&#x2F;AHP对指标赋权，改进等权假设
加权关联度


数据预处理改进：
采用对数标准化或Box-Cox变换处理非线性数据


分辨系数动态化：
根据数据离散程度自适应调整ρ值




（3）BP神经网络评价法BP神经网络（Back Propagation Neural Network）是一种基于误差反向传播算法的人工神经网络，可用于解决复杂的非线性评价问题。它通过模拟人脑神经元的连接方式，自动学习输入与输出之间的映射关系，适用于多指标、非线性、高维度的评价场景。

评价指标间存在非线性关系（如经济、生态、工程系统）
数据量大且维度高（如企业信用评估、医疗诊断）
传统方法（如AHP、TOPSIS）难以准确建模时




二、评价模型选择原则
根据数据类型选择：
定性数据多：AHP、模糊评价
定量数据多：熵权法、PCA、TOPSIS

根据评价目的选择：
排序优选：TOPSIS、灰色关联
效率评价：DEA
降维评价：PCA、因子分析

根据指标特性选择：
指标间相关性强：PCA、因子分析
指标独立性高：AHP、熵权法


方法对比表


方法
适用场景
权重确定
数据要求
主观性
计算复杂度



AHP
定性指标为主
主观
少量专家数据
高
中


PCA
高维数据降维
客观
大样本
无
高


模糊评价
模糊性评价
主客观
需隶属函数
中
中


熵权法
数据波动大的定量评价
客观
需足够变异
无
低


TOPSIS
多属性排序
需外赋
需标准化
低
中


DEA
效率评价
无权重
输入输出明确
无
高





方法
核心优势
主要局限
适用场景



AHP
定性指标处理能力强
主观性高
专家打分型评价


PCA
降维与去相关性
结果解释性差
高维数据预处理


模糊评价
处理模糊语义评价
隶属度构建主观
语言变量评价（如满意度）


熵权法
完全客观赋权
忽略指标实际意义
数据波动大的定量评价


TOPSIS
直观接近度排序
权重依赖外部输入
多方案优选


DEA
多输入输出效率评价
无法排序有效单元
效率评估（如医院、银行）


灰色关联
小样本计算
关联度区分度低
贫信息系统评价


三、注意事项
指标标准化：常用方法有极差法、Z-score法等
权重合理性：主观赋权需参考文献验证，客观赋权需数据支持
模型验证：可通过与实际案例对比验证模型有效性
结果解释：数学结果需结合实际意义进行合理解释

]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>working</tag>
      </tags>
  </entry>
  <entry>
    <title>mathorcup复盘</title>
    <url>/2025/04/22/mathorcup/</url>
    <content><![CDATA[一、论文格式1.公式全部用符号表示，下标不要过长。
2.图片上的字尽量用中文
3.问题背景等不能照搬原文，可能导致查重率高
4.代码标签
5.可视化部分的排版
6.摘要要囊括问题的结果
二、问题分析1.mathorcup第三题主要是评价模型跟机器学习。感觉机器学习作为比较新的领域在各个比赛中都有所体现。甚至A题直接上了视觉相关的，对完全没接触过的是非常吃亏的。后续还是需要多了解一下这一方面的内容跟知识吧。
2.可视化的部分最好在求解过程中做好规划，并保留好每一轮的数据。如果有问题，可以及时查看跟修正。
3.需要修改的部分，需要在飞书中显著标注出来，以免忘记，并在群里详细说明。当然当场解决是最好的啦。
4.强调一些特殊情况或者处理，发现有问题及时提出来。采用合理方法解决，很可能会成为加分项。
三、回顾
前期做的时候真的有点棘手，毕竟是第一次正是比赛。感觉考验还是蛮大的，当然也对队伍的磨合有很多正向的作用。每天打卡上班，屁股坐烂，但还是边骂边做，甚至还有板书等等。
哎太晚了，脑子转不动了，就说到这吧，晚安。
四、致谢4&#x2F;21的凌晨，终于舒舒服服地洗完澡，洗完衣服，收拾完。干干净净，清清爽爽的做着最后的收尾工作，等待迎来第一场数模比赛的圆满落幕。
从题目都搞不懂到见证论文一点点成形，被完善，养成系的快乐终于懂了。突然感觉很幸福，一个属于我们的成果（虽然可能还是一坨）终于要出来了欸。
感谢学校，让我舒服地洗了个热水澡，不是糟糕的冷热交替；感谢学长的宝贵指导，让我们的论文变得金玉其表，但是不妨碍是败絮其中哈哈哈哈。
感谢小孙（美工达人），能早起帮我们占教室，画了超级漂亮的图；感谢llc同学，被我征用了很久的充电器，终于不用背着板砖去上班；感谢我的队友们，让我的睡觉全勤。感谢妈妈的经费补贴，让我每天晚上都有夜宵吃（九点的晚饭）。感谢我的电脑，尽管呼噜噜个不停，但还是没有报废。感谢LadyGaGa拯救了我的耳朵，科切拉真的太绝了。
好了好了，我要去见证小破论文的出生了，再见。
To making it count.

]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>working</tag>
      </tags>
  </entry>
  <entry>
    <title>看不懂的GraphQL</title>
    <url>/2025/04/11/GraphQL/</url>
    <content><![CDATA[Before:什么是 API ？
Application Programming Interface – 应用程序编程接口
1. REST（Representational State Transfer）
特点：  
基于 HTTP 协议，使用标准方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE）。  
无状态：每次请求包含所有必要信息，服务器不保存会话状态。  
资源导向（URL 表示资源，如 /users/123）。  
返回数据格式通常为 JSON&#x2F;XML。


优点：  
简单易用，兼容性强，适合公开API（如Twitter、GitHub API）。  
可缓存（利用HTTP缓存机制）。


缺点：  
过度获取&#x2F;不足获取（Over-fetching&#x2F;Under-fetching）：客户端可能拿到多余或不足的数据。  
多个端点（Endpoint）可能导致维护复杂。




2. GraphQL
特点：  

由 Facebook 提出，采用 单端点（通常 /graphql）。  
查询语言：客户端可精确指定需要的数据字段和结构。  
返回数据格式为 JSON。


优点：  

灵活查询：避免REST的过度获取&#x2F;不足获取问题。  
强类型系统（通过Schema定义数据类型）。  
适合复杂前端需求（如多组件数据聚合）。


缺点：  

查询复杂度可能影响性能（需谨慎设计）。  
缓存实现比REST更复杂。


示例请求：  
POST /graphql HTTP/1.1Body: &#123;   query: &quot;&#123; user(id: 123) &#123; name, email &#125; &#125;&quot; &#125;


3. SOAP（Simple Object Access Protocol）
特点：  

基于 XML 的协议，通常通过 HTTP&#x2F;SMTP 传输。  
严格的消息格式（Envelope&#x2F;Header&#x2F;Body）。  
依赖 WSDL（Web Services Description Language）定义接口。


优点：  

高安全性（支持WS-Security等企业级标准）。  
适合企业级应用（如银行、政府系统）。


缺点：  

冗余度高（XML体积大，解析慢）。  
学习成本高，灵活性差。


示例请求：  
POST /soap-api HTTP/1.1Body: &lt;Envelope&gt;  &lt;Body&gt;    &lt;GetUser&gt;&lt;id&gt;123&lt;/id&gt;&lt;/GetUser&gt;  &lt;/Body&gt;&lt;/Envelope&gt;

对比总结


特性
REST
GraphQL
SOAP



协议
HTTP
HTTP
HTTP&#x2F;SMTP


数据格式
JSON&#x2F;XML
JSON
XML


端点
多端点（URL路径）
单端点（&#x2F;graphql）
单端点（通常）


查询灵活性
固定响应结构
客户端自定义查询&#x3D;&#x3D;
固定操作（WSDL）


性能
依赖设计
需优化查询
XML解析开销大


适用场景
公开API、简单CRUD
复杂前端需求
企业级系统


缓存
支持良好
需额外工具
困难



REST：适合简单、标准化的CRUD操作（如博客API）。  
GraphQL：适合前端需求多变、需聚合数据的场景（如社交平台）。  
SOAP：适合对安全性、事务一致性要求高的场景（如支付系统）。


graphQL网站指北：What is the GraphQL Foundation? | GraphQL
GraphQL是由 Facebook 在 2012 年创立的一门开源查询语言。GraphQL 作为通用的 REST 架构的替代方案而被开发出来**，它允许客户端只请求其需要的数据——不多也不少，一切在客户端的主导下**。
现实问题在一个 RESTful 架构下，因为后端开发人员定义在各个 URL 的资源上返回的数据，而不是前端开发人员来提出数据需求，使得按需获取数据会非常困难。经常前端需要请求一个资源中所有的信息，即便只需要其中的一部分数据。这个问题被称之为过度获取（overfetching）。最恶劣的场景下，一个客户端应用不得不请求多个而不是一个资源，这通常会发起多个网络请求。这不仅会造成过度获取的问题，也会造成瀑布式的网络请求**（waterfall network requests）**。
一个 GraphQL 操作可以是一个查询（query（读操作））、修改（mutation（写操作））以及订阅（subscription（持续读操作））。这些操作中每一种都只是根据 GraphQL 标准构造的一段字符串而已。
一旦一个 GraphQL 操作从前端应用到达后端应用，首先会在后端解释整个 GraphQL schema，然后再为前端解析相关的数据。GraphQL 并没有要求网络层选型（通常是 HTTP），也没有要求传输数据格式（通常是 JSON），（查询的语言跟返回的语言相似度比较高，这让 GraphQL 非常容易学习跟使用。）甚至没有要求应用架构（通常是前后端分离架构），它只是一个查询语言。

优势1.单一数据源（Single Source of Truth）在 GraphQL 应用中存在者单一数据源：GraphQL schema。它提供了一个所有可用数据检索的源头。鉴于 GraphQL 的 schema 通常会在服务端定义，客户端可以基于 schema 读取（query）和写入（mutation）数据。因此，服务端提供了所有可用的信息，客户端只需要执行 GraphQL 查询获取部分数据，或者通过 GraphQL 修改变更部分数据。
2.GraphQL 拥抱趋势GraphQL 适应了现在应用构建的变化趋势。你可能只有一个后端应用，但是可能会有多个依赖同一个后端应用的客户端（web 端、移动端、智能手表等等…）。因此 GraphQL 不仅能在前后端进行沟通，也能满足每一个客户端的具体要求（比如网络使用的要求、数据嵌套的要求、按需获取数据的要求），而不需要为每一个客户端定制不同的 API。
另外一方面，在服务端，可能不止一个后端应用，而是一个微服务集群来提供各自具体的功能。这简直是 GraphQL 的完美使用场景，它将所有的功能编织汇总到一个 GraphQL schema 汇总。
3.拼接 GraphQL Schema拼接 Schema 使得多个 schema 可以聚合成一个。什么时候你需要考虑这个？考虑一下后端的微服务架构。每个微服务处理特定域的业务逻辑和数据。因此，每个微服务都可以定义自己的GraphQL架构。之后，使用 Schema 拼接将所有 Schema 聚合到一个可以被客户端访问的 Schema 中。最终，每个微服务都可以拥有自己的 GraphQL 端点，而一个 GraphQL API网关将所有 schema 合并到一个全局 schema 中，以便使得客户端可以使用。
4.GraphQL 自省（Introspection）GraphQL 自省允许通过 GraphQL API 检索 GraphQL schema。因为 schema 包含了包含了 GraphQL API 可以获得的所有数据信息，本身就是一份完美的自动生成的 API 文档。不仅仅是 API 的文档，也允许客户端通过mock GraphQL 的 schema 达到测试的目的，或者使用 schema 拼接的接口检索多个微服务的 schema。
5.强类型的 GraphQLGraphQL 是一门强类型的查询语言，因为它是通过 GraphQL Schema Definition Language（SDL）书写的。因为有了强类型，它就拥有了强类型编程语言一样的好处：更不容出错、可以在编辑期验证并且支持编辑器智能补全和验证相关的集成。

缺点1.GraphQL 查询的复杂性GraphQL 仅仅是一个查询语言。在服务端，一个查询需要解析数据，因此一个 GraphQL 相关实现常常需要执行数据库访问，但 GraphQL 其实不关心这些。还有，GraphQL 在你需要在一个查询中获取多个字段（作者、文章、评论）的时候，它对性能瓶颈没有任何帮助。无论使用 RESTful 架构还是 GraphQL，不同资源&#x2F;字段仍然需要从一个数据源去获取。
因此当一个客户端需要一次查询很多嵌套字段时，前端开发通常不能很清楚他正在通过服务端访问不同的数据库获取过多的数据。这需要一种机制（比如最深查询深度、查询复杂度权重、避免递归、持久化查询）来制止来自客户端的（性能）昂贵的查询。
2.查询频率限制另一个问题是频率限制，在 REST 中，可以简单的声明”一天之中，我们只允许请求这么多资源“，在一个独立的 GraphQL 操作中很难做到这一点，因为任何操作的开销都可以是廉价的或者昂贵的。这就是那些有着公共 GraphQL API 的公司提出的特定速率限制计算，通常可以归结为前面提到的最大查询深度和查询复杂度权重问题。
3.GraphQL 缓存一个简单缓存，相比 REST，在 GraphQL 中实现会变得极其复杂。在 GraphQL 中就复杂了，因为即便它操作的是同一个实体，每个查询都各不相同。
比如，一个查询中，你可能只会请求一个作者的名字，但是在另外一次查询中你可能也想知道他的电子邮箱地址。这就需要你有一个更加健全的机制中来确保字段级别的缓存，实现起来并不简单。
GraphQL 的延伸，graphical &amp; graph(s)
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>working</tag>
      </tags>
  </entry>
  <entry>
    <title>关于四月</title>
    <url>/2025/04/09/about_April/</url>
    <content><![CDATA[风赶着河流
鸟争着清晨
花赶着开
三月很忙
十万人间
赶出一个春天
于是
四月是异常拥挤的新绿
晚安，祝大家都有一夜好梦​​
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>Y_daily</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/04/04/hello-world/</url>
    <content><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &quot;My New Post&quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
]]></content>
  </entry>
</search>
