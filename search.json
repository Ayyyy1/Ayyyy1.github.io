[{"title":"mathorcup复盘","url":"/2025/04/22/mathorcup/","content":"\n\n\n## 一、论文格式\n\n1.公式全部用符号表示，下标不要过长。\n\n2.图片上的字尽量用中文\n\n3.问题背景等不能照搬原文，可能导致查重率高\n\n4.代码标签\n\n5.可视化部分的排版\n\n6.摘要要囊括问题的结果\n\n## 二、问题分析\n\n1.mathorcup第三题主要是评价模型跟机器学习。感觉机器学习作为比较新的领域在各个比赛中都有所体现。甚至A题直接上了视觉相关的，对完全没接触过的是非常吃亏的。后续还是需要多了解一下这一方面的内容跟知识吧。\n\n2.可视化的部分最好在求解过程中做好规划，并保留好每一轮的数据。如果有问题，可以及时查看跟修正。\n\n3.需要修改的部分，需要在飞书中显著标注出来，以免忘记，并在群里详细说明。当然当场解决是最好的啦。\n\n4.强调一些特殊情况或者处理，发现有问题及时提出来。采用合理方法解决，很可能会成为加分项。\n\n## 三、回顾\n\n![bang](bang.jpg)\n\n前期做的时候真的有点棘手，毕竟是第一次正是比赛。感觉考验还是蛮大的，当然也对队伍的磨合有很多正向的作用。每天打卡上班，屁股坐烂，但还是边骂边做，甚至还有板书等等。\n\n哎太晚了，脑子转不动了，就说到这吧，晚安。\n\n## 四、致谢\n\n4/21的凌晨，终于舒舒服服地洗完澡，洗完衣服，收拾完。干干净净，清清爽爽的做着最后的收尾工作，等待迎来第一场数模比赛的圆满落幕。\n\n从题目都搞不懂到见证论文一点点成形，被完善，养成系的快乐终于懂了。突然感觉很幸福，一个属于我们的成果（虽然可能还是一坨）终于要出来了欸。\n\n感谢学校，让我舒服地洗了个热水澡，不是糟糕的冷热交替；感谢学长的宝贵指导，让我们的论文变得金玉其表，但是不妨碍是败絮其中哈哈哈哈。\n\n感谢小孙（美工达人），能早起帮我们占教室，画了超级漂亮的图；感谢llc同学，被我征用了很久的充电器，终于不用背着板砖去上班；感谢我的队友们，让我的睡觉全勤。感谢妈妈的经费补贴，让我每天晚上都有夜宵吃（九点的晚饭）。感谢我的电脑，尽管呼噜噜个不停，但还是没有报废。感谢LadyGaGa拯救了我的耳朵，科切拉真的太绝了。\n\n好了好了，我要去见证小破论文的出生了，再见。\n\nTo making it count.\n\n![count](count.jpg)\n","tags":["working"],"categories":["数学建模"]},{"title":"看不懂的GraphQL","url":"/2025/04/11/GraphQL/","content":"\nBefore:什么是 API ？\n\n**A**pplication **P**rogramming **I**nterface -- 应用程序编程接口\n\n#### **1. REST（Representational State Transfer）**\n\n- **特点**：  \n  - 基于 **HTTP 协议**，使用标准方法（GET/POST/PUT/DELETE）。  \n  - **无状态**：每次请求包含所有必要信息，服务器**不保存会话状态**。  \n  - 资源导向（URL 表示资源，如 `/users/123`）。  \n  - 返回数据格式通常为 **JSON/XML**。  \n- **优点**：  \n  - 简单易用，兼容性强，适合公开API（如Twitter、GitHub API）。  \n  - 可缓存（利用HTTP缓存机制）。  \n- **缺点**：  \n  - **过度获取/不足获取**（Over-fetching/Under-fetching）：客户端可能拿到多余或不足的数据。  \n  - 多个端点（Endpoint）可能导致维护复杂。  \n\n---\n\n#### **2. GraphQL**\n\n- **特点**：  \n\n  - 由 **Facebook** 提出，采用 **单端点**（通常 `/graphql`）。  \n  - **查询语言**：客户端可**精确指定**需要的数据字段和结构。  \n  - 返回数据格式为 **JSON**。  \n\n- **优点**：  \n\n  - **灵活查询**：避免REST的过度获取/不足获取问题。  \n  - 强类型系统（通过Schema定义数据类型）。  \n  - 适合复杂前端需求（如多组件数据聚合）。  \n\n- **缺点**：  \n\n  - 查询复杂度可能影响性能（需谨慎设计）。  \n  - 缓存实现比REST更复杂。  \n\n- **示例请求**：  \n\n  ```graphql\n  POST /graphql HTTP/1.1\n  Body: { \n    query: \"{ user(id: 123) { name, email } }\" \n  }\n  ```\n\n---\n\n#### **3. SOAP（Simple Object Access Protocol）**\n\n- **特点**：  \n\n  - 基于 **XML** 的协议，通常通过 **HTTP/SMTP** 传输。  \n  - 严格的消息格式（Envelope/Header/Body）。  \n  - 依赖 **WSDL**（Web Services Description Language）定义接口。  \n\n- **优点**：  \n\n  - 高安全性（支持WS-Security等企业级标准）。  \n  - 适合**企业级应用**（如银行、政府系统）。  \n\n- **缺点**：  \n\n  - 冗余度高（XML体积大，解析慢）。  \n  - 学习成本高，灵活性差。  \n\n- **示例请求**：  \n\n  ```xml\n  POST /soap-api HTTP/1.1\n  Body: \n  <Envelope>\n    <Body>\n      <GetUser><id>123</id></GetUser>\n    </Body>\n  </Envelope>\n  ```\n\n### **对比总结**\n\n| 特性           | REST              | GraphQL            | SOAP             |\n| -------------- | ----------------- | ------------------ | ---------------- |\n| **协议**       | HTTP              | HTTP               | HTTP/SMTP        |\n| **数据格式**   | JSON/XML          | JSON               | XML              |\n| **端点**       | 多端点（URL路径） | 单端点（/graphql） | 单端点（通常）   |\n| **查询灵活性** | 固定响应结构      | 客户端自定义查询== | 固定操作（WSDL） |\n| **性能**       | 依赖设计          | 需优化查询         | XML解析开销大    |\n| **适用场景**   | 公开API、简单CRUD | 复杂前端需求       | 企业级系统       |\n| **缓存**       | 支持良好          | 需额外工具         | 困难             |\n\n- **REST**：适合简单、标准化的CRUD操作（如博客API）。  \n- **GraphQL**：适合前端需求多变、需聚合数据的场景（如社交平台）。  \n- **SOAP**：适合对安全性、事务一致性要求高的场景（如支付系统）。  \n\n---\n\n# graphQL\n\n网站指北：[What is the GraphQL Foundation? | GraphQL](https://graphql.cn/foundation/)\n\nGraphQL是由 Facebook 在 2012 年创立的一门开源**查询语言**。GraphQL 作为通用的 REST 架构的替代方案而被开发出来**，它允许客户端只请求其需要的数据——不多也不少，一切在客户端的主导下**。\n\n### 现实问题\n\n在一个 RESTful 架构下，因为后端开发人员定义在各个 URL 的资源上返回的数据，而不是前端开发人员来提出数据需求，使得按需获取数据会非常困难。经常前端需要请求一个资源中所有的信息，即便只需要其中的一部分数据。这个问题被称之为**过度获取（overfetching）**。最恶劣的场景下，一个客户端应用不得不请求多个而不是一个资源，这通常会发起多个网络请求。这不仅会造成过度获取的问题，也会造成瀑布式的网络请求**（waterfall network requests）**。\n\n一个 GraphQL 操作可以是一个查询（query（读操作））、修改（mutation（写操作））以及订阅（subscription（持续读操作））。这些操作中每一种都只是根据 GraphQL 标准构造的一段字符串而已。\n\n一旦一个 GraphQL 操作从前端应用到达后端应用，首先会在后端解释整个 [GraphQL schema](https://zhida.zhihu.com/search?content_id=7793521&content_type=Article&match_order=1&q=GraphQL+schema&zhida_source=entity)，然后再为前端解析相关的数据。GraphQL 并没有要求网络层选型（通常是 HTTP），也没有要求传输数据格式（通常是 JSON），（查询的语言跟返回的语言相似度比较高，这让 GraphQL **非常容易学习跟使用**。）甚至没有要求应用架构（通常是前后端分离架构），它只是一个查询语言。\n\n---\n\n### 优势\n\n#### 1.单一数据源（Single Source of Truth）\n\n在 GraphQL 应用中存在者单一数据源：**GraphQL schema**。它提供了一个所有可用数据检索的源头。鉴于 GraphQL 的 schema 通常会在服务端定义，客户端可以基于 schema 读取（query）和写入（mutation）数据。因此，服务端提供了所有可用的信息，客户端只需要执行 GraphQL 查询获取部分数据，或者通过 GraphQL 修改变更部分数据。\n\n#### 2.GraphQL 拥抱趋势\n\nGraphQL 适应了现在应用构建的变化趋势。你可能只有一个后端应用，但是可能会有多个依赖同一个后端应用的客户端（web 端、移动端、智能手表等等...）。因此 GraphQL 不仅能在前后端进行沟通，也能满足每一个客户端的具体要求（比如网络使用的要求、数据嵌套的要求、按需获取数据的要求），而不需要为每一个客户端定制不同的 API。\n\n另外一方面，在服务端，可能不止一个后端应用，而是一个微服务集群来提供各自具体的功能。这简直是 GraphQL 的完美使用场景，它将所有的功能编织汇总到一个 **GraphQL schema 汇总**。\n\n#### 3.拼接 GraphQL Schema\n\n拼接 Schema 使得多个 schema 可以聚合成一个。什么时候你需要考虑这个？考虑一下后端的微服务架构。每个微服务处理特定域的业务逻辑和数据。因此，每个微服务都可以定义自己的GraphQL架构。之后，使用 Schema 拼接将所有 Schema 聚合到一个可以被客户端访问的 Schema 中。最终，每个微服务都可以拥有自己的 GraphQL 端点，而一个[ GraphQL API网关](https://zhida.zhihu.com/search?content_id=7793521&content_type=Article&match_order=1&q=+GraphQL+API网关&zhida_source=entity)将所有 schema 合并到一个全局 schema 中，以便使得客户端可以使用。\n\n#### 4.GraphQL 自省（Introspection）\n\nGraphQL 自省允许通过 GraphQL API 检索 GraphQL schema。因为 schema 包含了包含了 GraphQL API 可以获得的所有数据信息，本身就是一份完美的自动生成的 API 文档。不仅仅是 API 的文档，也允许客户端通过mock GraphQL 的 schema 达到测试的目的，或者使用 schema 拼接的接口**检索多个微服务**的 schema。\n\n#### 5.强类型的 GraphQL\n\nGraphQL 是一门强类型的查询语言，因为它是通过 GraphQL Schema Definition Language（SDL）书写的。因为有了强类型，它就拥有了强类型编程语言一样的好处：更不容出错、可以在编辑期验证并且支持编辑器智能补全和验证相关的集成。\n\n---\n\n### 缺点\n\n#### 1.GraphQL 查询的复杂性\n\nGraphQL 仅仅是一个查询语言。在服务端，一个查询需要解析数据，因此一个 GraphQL 相关实现常常需要执行数据库访问，但 GraphQL 其实不关心这些。还有，GraphQL 在你需要在一个查询中获取多个字段（作者、文章、评论）的时候，它对性能瓶颈没有任何帮助。无论使用 RESTful 架构还是 GraphQL，不同资源/字段仍然需要从一个数据源去获取。\n\n因此当一个客户端需要一次查询很多嵌套字段时，前端开发通常不能很清楚他正在通过服务端访问不同的数据库获取过多的数据。这需要一种机制（比如最深查询深度、查询复杂度权重、避免递归、持久化查询）来制止来自客户端的（性能）昂贵的查询。\n\n#### 2.查询频率限制\n\n另一个问题是频率限制，在 REST 中，可以简单的声明”一天之中，我们只允许请求这么多资源“，在一个独立的 GraphQL 操作中很难做到这一点，因为任何操作的开销都可以是廉价的或者昂贵的。这就是那些有着公共 GraphQL API 的公司提出的**特定速率限制计算**，通常可以归结为前面提到的最大查询深度和查询复杂度权重问题。\n\n#### 3.GraphQL 缓存\n\n一个简单缓存，相比 REST，在 GraphQL 中实现会变得极其复杂。在 GraphQL 中就复杂了，因为即便它操作的是同一个实体，每个查询都各不相同。\n\n比如，一个查询中，你可能只会请求一个作者的名字，但是在另外一次查询中你可能也想知道他的电子邮箱地址。这就需要你有一个更加健全的机制中来确保字段级别的缓存，实现起来并不简单。\n\n##### GraphQL 的延伸，graphical & graph(s)\n\n![graphQL](/images/graphQL.gif)\n","tags":["working"],"categories":["CTF"]},{"title":"关于四月","url":"/2025/04/09/about_April/","content":"\n风赶着河流\n\n鸟争着清晨\n\n花赶着开\n\n三月很忙\n\n十万人间\n\n赶出一个春天\n\n于是\n\n四月是异常拥挤的新绿\n\n晚安，祝大家都有一夜好梦​​\n","tags":["Y_daily"],"categories":["life"]},{"title":"Hello World","url":"/2025/04/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]